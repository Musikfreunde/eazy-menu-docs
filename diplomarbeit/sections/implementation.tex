\section {Systemarchitektur}
\author{Benjamin Besic}

\begin{figure}[htp]
    \centering
    \author{David Ignjatovic}
    \includegraphics[scale=0.7]{pics/final-sys-arc.PNG}
    \caption{Systemarchitektur des Programms}
    \label{fig:impl:SysArc}
\end{figure}

\section{Datenmodell}
\author{David Ignjatovic}

Ein Datenmodell wird als Darstellung der relevanten Objekte eines Projektes verwendet. 
Unser Datenmodell ist im Großen und Ganzen immer gleichgeblieben. Für den Algorithmus aber haben wir es aber erweitern müssen.

\subsection{Entitäten}

Eine Entität ist ein bestimmtes Objekt mit den jeweiligen Atributen. Atribute sind die Eigenschaften eins Objektes.
Unser Projektes beinhaltet 5 Entitäten:

\begin{itemize}
  \item Bestellung
  \item Categories
  \item Kantine
  \item Menue
  \item Oeffungszeit
\end{itemize}

\subsection{Bestellung} 

Die Entität Bestellung enthält die wichtigsten Informationen über einen Mitarbeiter und die dazu ausgewählte Mahlzeit.
Zur Identifikation einer Bestellung verwenden wir eine Id welche generiert wird. \\*

In der Bestellung wird angegebebn von wem die Bestellung bestellt wurde und ob der Mitarbeiter es auch für sich selbst bestellt hat oder für jemand anderen. 
Jeder Mitarbeiter der Firma hat auch eine Personalnummer. Bei jeder Bestellung gibt es die möglichkeit einen Kommentar abzugeben. Dieser wird an die Kantine mitgegeben. Natürlich hat man auch die nöglichkeit 
eine Mahlzeit öfters zu bestellen. Somit hat jeder Mitarbeiter die möglichkeit eine Bestellanzahl mitzugeben. Für das bestellen, bearbeiten aber auch stonieren werden immer die jetztige uhrzeit mitgegeben. \\*

Das wichtigste in der Bestellung ist die Mahlzeit und für wann es bestellt wurde. Dafür verwenden wir die zwei klassen, Oeffnungszeit und Menue. \\*


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{lstlisting}
    @SequenceGenerator(name = "bestellung_seq_gen", 
                        sequenceName = "BESTELLUNG_SEQ",
                        allocationSize=1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, 
                        generator = "bestellung_seq_gen")
    @Id
    @Column(name = "BESTELLUNG_ID")
    private Long id;

    @Column(name = "BESTELLTVON",length = 32)
    private String orderedBy;

    @Column(name = "BESTELLTFUER",length = 32)
    private String orderedFor;

    @Column(name = "KOMMENTAR",length = 4000)
    private String comment;

    @Column(name = "PERSONALNUMMER")
    private Long personalNumber;

    @Column(name = "ANZAHL")
    private int menueCounter;

    @Column(name = "STORNIERTUM",length = 6)
    private Timestamp canceledAt;

    @Column(name = "ABGERECHNETUM")
    private Timestamp settledAt;

    @Column(name = "KOSTENSTELLE")
    private Integer moneyPool;

    @Column(name = "ANGELEGTUM",length = 6)
    private Timestamp createdAt;

    @Column(name = "ANGELEGTVON",length = 32)
    private String createdBy;

    @Column(name = "GEAENDERTUM",length = 6)
    private Timestamp changedAt;

    @Column(name = "GEAENDERTVON",length = 32)
    private String changedBy;

    @ManyToOne
    @JoinColumn(name = "OEFFNUNGSZEIT_ID")
    private Oeffnungszeit oeffnungszeit;

    @ManyToOne
    @JoinColumn(name = "MENUE_ID")
    private Menue menue;
\end{lstlisting}

\subsection{Categories}

Die Entität Categories ist ein Enum, welches wir Hauptsächlich für unseren Algorithmus verwenden. Es besteht aus 4 einträgen: \\*


\begin{itemize}
    \item Vegetarisch
    \item Vegan
    \item Schwein
    \item Rind
    \item Huhn
    \item Pute
    \item Salat
    \item Nudel
    \item Süß
    \item Fisch
    \item Sonstiges
\end{itemize}

Die einzelnen Kategorien beschreiben eine Mahlezeit. Sommit kann man ganz einfach zwischen einzelnen Mahlezeiten unterscheiden und sie auch gruppieren.

\subsection{Kantine}

In der Entitäten Kantine befinden sich die wichtigsten Informationen über eine Kantine wie zum Beispiel ob eine Kantine offen ist oder zurzeit geschlossen ist. 
Eine kleine Beschreibung über die Kantine und über das Service ist ebenso enthalten. \\*

\begin{lstlisting}
    @Id
    @Column(name = "KANTINE_ID")
    private Long id;

    @Column(name = "KANTINENBEZEICHNUNG", length = 200)
    private String canteenDesc;

    @Column(name = "SERVICEBEZEICHNUNG", length = 200)
    private String serviceDesc;

    @Column(name = "STATUSKZ", length = 1)
    private char status;

    @Column(name = "ANGELEGTUM",length = 6)
    private Timestamp createdAt;

    @Column(name = "ANGELEGTVON",length = 32)
    private String createdBy;

    @Column(name = "GEAENDERTUM",length = 6)
    private Timestamp changedAt;

    @Column(name = "GEAENDERTVON",length = 32)
    private String changedBy;

\end{lstlisting}

\subsection{Menue}

In der Entität Menue stehen die wichtigsten Informationen über ein Menü. Ein Menü beinhaltet eine Vorspeise, Hauptspeise, Nachspeise und ein Dessert. 
Noch dazu findet man in der Entität ein Datum, um zuzuordnen wann das Menü bestellt wurde. \\*
Neben dem Bestelldatum beinhaltet die Entität Menue auch noch weiter Timestamps.
Die verwendeten Timestamps werden verwendet, um zu speichern, wann ein Menue erstellt wurde oder wann ein Menue geändert wurde. Natürlich wird auch mitgespeichert von wem diese Änderungen durchgeführt wurden. \\*

Die bereits oben genannten Kategorien finden wir in der Entität Menue. 
Diese werden verwendet, um einzelne Menüs zu unterscheiden und mit Hilfe der Kategorien und unserem Algorithmus kann man einfach hervorwagen welche Mahlzeit zu welchem Mitarbeiter am besten passt. \\*

Für jedes Menü wird auch die dazu ausgewählte Kantine mitgespeichert. So weiß man, zu welcher Kantine der Mitarbeiter gehen muss, um sein Menü zu bekommen. \\*

\begin{lstlisting}
    @SequenceGenerator(name = "menue_seq_gen", 
                        sequenceName = "MENUE_SEQ",
                        allocationSize=1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, 
                    generator = "menue_seq_gen")
    @Id
    @Column(name = "MENUE_ID")
    private Long id;

    @Column(name = "MENUEDATUM")
    private LocalDate date;

    @Column(name = "MENUECODE", length = 1)
    private char code;

    @Column(name = "VORSPEISE", length = 2000)
    private String appetizer;

    @Column(name = "HAUPTSPEISE", length = 2000)
    private String mainDish;

    @Column(name = "NACHSPEISE", length = 2000)
    private String desert;

    @Column(name = "ANGELEGTUM",length = 6)
    private Timestamp createdAt;

    @Column(name = "ANGELEGTVON",length = 32)
    private String createdBy;

    @Column(name = "GEAENDERTUM",length = 6)
    private Timestamp changedAt;

    @Column(name = "GEAENDERTVON",length = 32)
    private String changedBy;

    @Column(name = "CATEGORIES",length = 255)
    private String categories;

    @ManyToOne
    @JoinColumn(name = "KANTINE_ID")
    private Kantine kantine;
\end{lstlisting}

\subsection{Oeffnungszeit}

Die Entitäten Oeffnungszeit zeigt an, ob ein Kantinenraum in Verwendung ist und ob die Maximale Anzahl an Sitzplätzen schon belegt ist. Das Zeitfenster welches beschreibt wann gegessen wird, wird ebenso mitgespeichert. \\*

Um zu wissen welcher Kantinenraum gemeint wird,  wird auch die verwendete Kantine mitgespeichert. \\*

\begin{lstlisting}
    @Id
    @Column(name = "OEFFNUNGSZEIT_ID")
    private Long id;

    @Column(name = "STATUSKZ", length = 1)
    private char status;

    @Column(name = "ZEITFENSTERVON", length = 5)
    private String timeWindowFrom;

    @Column(name = "ZEITFEnSTERBIS", length = 5)
    private String timeWindowTo;

    @Column(name = "MAXPLAETZE", nullable = true)
    private Integer maxPositions;

    @Column(name = "ANGELEGTUM",length = 6)
    private Timestamp createdAt;

    @Column(name = "ANGELEGTVON",length = 32)
    private String createdBy;

    @Column(name = "GEAENDERTUM",length = 6)
    private Timestamp changedAt;

    @Column(name = "GEAENDERTVON",length = 32)
    private String changedBy;

    @ManyToOne
    @JoinColumn(name = "KANTINE_ID")
    private Kantine kantine;
\end{lstlisting}

\section{REST-Schnittstellen}

\subsection{Bestellung}

\paragraph{Bestellungen von allen Mitarbeitern}

\paragraph{Anzahl der Bestellungen pro Wochentag eines Mitarbeitern}

\paragraph{Anzahl der Bestellungen pro Wochentag eines Mitarbeitern}

\paragraph{Alle Kategorien von einem bestimmten Mitarbeiter}

\paragraph{Alle Kategorien}

\paragraph{Alle Bestellungen an einem bestimmten Tag}

\paragraph{Bestellung erstellen}

\paragraph{Bestellung stornieren}



\subsection{Menue}

\paragraph{Alle Menüs}

\paragraph{Menü erstellen}

\paragraph{Menü verändern}

\paragraph{Menü-Vorschlag (Recomendation)}

\paragraph{Alle Menüs an einem bestimmten Tag}


\subsection{Oeffnungszeiten}

\paragraph{Alle Aktiven Essenszeiten}

\paragraph{Freien Tische}


\section{Authentifizierung}

\section {Interface Webapp}
\author{Benjamin Besic}
\subsection{Login}
Beim Aufrufen der Webapp wird man zunächst zu der Login-Seite weitergeleitet. Wie diese fungiert, sieht man in der nächsten Abbildung. \\*
Der Login dient in erster Hinsicht dazu, um festzustellen ob der Benutzer ein Mitarbeiter oder Kantinenmitarbeiter ist.
Denn nach dem Login wird man entweder zur Mitarbeiter-Ansicht oder Kantinenmitarbeiter-Ansicht weitergeleitet. \\*
*Abbildung Login*

\subsection {Mitarbeiter-Ansicht}

\subsubsection {Home}
\label{sec:MitHome}
Das Erste, was ein Mitarbeiter zu sehen bekommt, ist die Home Ansicht. In dieser Ansicht ist eine Kalender und die Menüauswahl enthalten. \\*
Der Benutzer kann im Kalender das gewünschte Bestelldatum anklicken, dadurch wird automatisch die Menüauswahl aktualisiert. Man kann sich in die Zukunft, sowohl auch 
in die Vergangenheit klicken, um sich Auskunft über die vergangenen/kommenden Menüs zu beschaffen. Die Ansicht ist nur auf die Bestelltage beschränkt, an denen Menüs angeboten werden.\\*
Nach der erfolgreichen Datumswahl hat man unten drei Menüs zur Auswahl, sowohl wie die dazugehörige Vor- und Nachspeise. Das dem Benutzer empfohlene Menü (Analyse aus seinem Bestellverlauf) wird grün hinterlegt.
Neben den Bestellköpfen befindet sich ein Fragezeichen-Knopf, wenn man über diesen geht werden einem die Kategorien des Menüs angezeigt.
\\* Wenn die Bedingungen für eine Bestellung erfüllt sind,
kann man auf einen der drei Bestellknöpfe drücken, um zur Bestellansicht weitergeleitet zu werden. Sind diese Bedingungen nicht erfüllt, sind die Knöpfe ausgeschaltet. \\*
Weiters werden unter den Menüs noch relevante Informationen angezeigt. Durch das Klicken des Fragezeichen-Knopfs wird ein Bild der 14 Allergene geöffnet.

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.35]{pics/mitarbeiter-home.JPG}
    \caption{Home Ansicht eines Mitarbeiters}
    \label{fig:impl:HomeMitarbeiter}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.5]{pics/kategorien_mitarbeiter.JPG}
    \caption{Kategorieanzeige eines Menüs}
    \label{fig:impl:CategoriesForMenue}
\end{figure}

\pagebreak

\subsubsection {Bestellansicht}

In der Bestellansicht werden die nötigen Daten für die Bestellung ausgefüllt. Die ersten drei Felder sind automatisch ausgefüllt, aufgrund der vorherigen Auswahl. \\*
Die Tabelle auf der rechten Seite enthält alle Bestellzeiträume, die es gibt. Man kann nur eine gleichzeitig auswählen. Außerdem stehen die freien Plätze dabei, die aus der Datenbank geladen werden.\\*
Die Anzahl der Menüs kann durchs Klicken des Plus- und Minusknopfs angepasst werden.  \\*
Darunter steht voreingestellt der Benutzer, doch dies kann verändert werden, um das Menü für einen anderen Mitarbeiter bestellen zu können. \\*
Abschließend kann man noch einen Kommentar an die Kantine mitgeben, falls es etwaige Extrawünsche geben sollte. \\*
Die Bestellung kann durch den Abschließen-Knopf durchgeführt werden und Abbrechen kann man jederzeit mit dem Abbrechen-Knopf.
Die Bestellung ist erst ausführbar, sobald alle Felder außer des Kommentars ausgefüllt wurden.
\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.7]{pics/mitarbeiter-bestellen.JPG}
    \caption{Bestellansicht}
    \label{fig:impl:BestellenMitarbeiter}
\end{figure}
\pagebreak

\subsubsection {Bestellübersicht}

Die Bestellübersicht dient dem Benutzer dazu seine Bestellhistorie nachzuvollziehen. Zu jeder Bestellung ist der Name des bestellten Menüs, das Menüdatum, der Bestellzeitpunkt und die Essenszeit zugeordnet. \\*
Der Benutzer hat die Möglichkeit, oben in der Suchleiste, die Bestellungen nach Name oder Menüdatum zu filtern. Das Filtern erfolgt direkt nach der Eingabe. \\*
Man kann jede Bestellung anklicken und falls eine Bestellung die Stornierbedingungen erfüllt kann diese mit dem unten gelegen Storno-Button storniert werden.
Nach einer erfolgreichen Stornierung verschwindet die Bestellung aus dem Verlauf, doch in der Datenbank wird nur das Stornierdatum gesetzt und somit wird die Bestellung ungültig gemacht. 


\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.4]{pics/mitarbeiter-bestellen-übersicht.JPG}
    \caption{Bestellungsübersicht}
    \label{fig:impl:BestellenMitarbeiterUebersicht}
\end{figure}
\pagebreak

\subsubsection {Statistiken}

Der Benutzer kann in dieser Ansicht mehr Informationen über seine vergangenen Bestellungen bekommen.
Durch das Wechseln des Tabs oben links wird entweder eine Statistik über die Kategorien oder über die Wochentage angezeigt.

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.3]{pics/statistiken_kategorien.JPG}
    \caption{Kategorie Statistiken}
    \label{fig:impl:StatsCategories}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.3]{pics/statistiken_wochentage.JPG}
    \caption{Wochentage Statistiken}
    \label{fig:impl:WeekDaysCategories}
\end{figure}

\pagebreak

\subsection {Kantinen-Ansicht}
\subsubsection {Home}

Die Startseite der Kantinenmitarbeiter ähnelt der Ansicht der Mitarbeiter. \hyperref[sec:MitHome]{Siehe hier}. \\*
Die Unterschiede sind, dass die Kantine Textfelder für jedes Menü und dessen Vor- und Nachspeise hat.
Ebenfalls erscheint beim Kategorien-Knopf eine Liste von Kategorien zum Anhaken, um dem Menü die entsprechenden Kategorien zuzuordnen. \\*
Die Textfelder und Kategorien können bearbeitet werden, um ein vorhandenes Menü zu aktualisieren oder um ein neues zu erstellen.
Die Erstellung bzw. die Änderung kann durch den Speichern-Knopf durchgeführt werden. Je nach Fall werden neue Menüs an das Backend geschickt oder ein
vorhandenes wird aktualisiert.

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.35]{pics/kantine_home.JPG}
    \caption{Kantine Homeansicht}
    \label{fig:impl:CantineHome}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.4]{pics/kategorien_kantine.JPG}
    \caption{Kategorieauswahl}
    \label{fig:impl:CategoryChooseCantine}
\end{figure}
\pagebreak

\subsubsection {Drucken}

Die Druckansicht dient den Kantinenmitarbeitern dazu, um die Bestellungen des jeweiligen Tages auch durchführen zu können.
Der Tag kann durch eine Datumsauswahl bestimmt werden.
Die Ansicht zeigt alle nötigen Informationen, damit die Kantine einen Überblick über die Bestellungen hat und dementsprechend das Essen vorbereiten kann.
Es sind die Essenszeiten sowie Anzahl der jeweiligen Menücodes summiert für einen schnellen Überblick. \\*
Durch das Drücken des Drucken-Knopfs hat die Kantine die Möglichkeit ein pdf-Dokument aus der kompletten Ansicht, die unter dem Knopf zu sehen ist, zu drucken.
Dies dient dazu, dass sie einen Ausdruck auf Papier haben, der für die Kantine praktischer ist.

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.45]{pics/kantine_drucken.JPG}
    \caption{Druckansicht der Kantine}
    \label{fig:impl:CantinePrint}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[scale=1]{pics/pdf_ansicht.JPG}
    \caption{PDF der Ansicht}
    \label{fig:impl:CantinePrintPDF}
\end{figure}
\pagebreak

\section {Interface Android-App}
\author{Bozidar Spasenovic}


\section{Login}
\begin{figure}[htp]
    \centering
    \author{Bozidar Spasenovic}
    \includegraphics[scale=0.1]{pics/LoginScreenAnndroid.png}
    \caption{Loginscreen Android}
    \label{fig:impl:LoginScreenAnndroid}
\end{figure}

\subsection{Authentification}
Die Authentifizierung erfolgt mit der Methode checkAccessToken, welche nichts anderes macht wie den Keycloak nach einem Token für den User zu fragen.
Kriegt man einen Token zurück, so besteht der User.

\begin{lstlisting}

    Button(onClick = {
        if (!name.isEmpty() && !password.isEmpty() && checkAccessToken()) {

            InitMenues()
            InitBestellungen(name)
            Toast.makeText(
                context,
                "Logged in successfully",
                Toast.LENGTH_SHORT
            ).show()
            isLoggedIn.value = true
            navController.navigate("uebersicht")

        }
    }) {
        Text(text = "Sign In")
    }

\end{lstlisting}

\subsubsection{checkAccessToken()}

Man schickt einen Request an http://10.0.2.2:8082/auth/realms/menuRealm/protocol/openid-connect/token mit einem passendem body.
Im body stehen die Felder die für den Request nötig sind wie zum Beispiel:
\begin{itemize}
    \item die Client ID
    \item der Grant Type 
    \item der Client Secret
    \item der Scope
    \item das Passwort
    \item der Username
\end{itemize}

Als Client wird ein OkHttpClient verwendet. Dieser erstellt einen neuen Aufruf mit dem erstelltem Request. 
Er wartet auf einen Response und speichert bei einem erfolgreichem Response den Token. Da es zu Internet Problemen kommen kann haben wir
einen countDownLatch eingebaut, der vor der Rückgabe der Methode darauf wartet, dass der Token gespeichert worden ist.  

\begin{lstlisting}
    client.newCall(request).enqueue(object : Callback {
        override fun onResponse(call: Call, response: Response) {
            response.use {
                if (response.isSuccessful) {
                    accessToken.value = response.body!!.string()
                }
                else{
                    throw IOException("Unexpected code $response")
                }
            }
            countDownLatch.countDown()
        }
        override fun onFailure(call: Call, e: IOException) {
            e.printStackTrace()
            countDownLatch.countDown()

        }
    })
    countDownLatch.await()
    return accessToken.value != ""
\end{lstlisting}

\subsection{Log out}
Der Mitarbeiter hat eine Möglichkeit sich auch aus der App auszuloggen. Das erfolgt durch den Sign out Button.
\begin{figure}[htp]
    \centering
    \author{Bozidar Spasenovic}
    \includegraphics[scale=0.09]{pics/SignOutScreenAnndroid.png}
    \caption{Signout Android}
    \label{fig:impl:SignOutScreenAnndroid}
\end{figure}

Nach dem einloggen wird die Methode InitBestellungen() aufgerufen. Ihre Aufgabe ist es den derzeitigen Bestellungsverlauf des Mitarbeiters zu initialisieren.
Den kann man dann auch in der Verlaufsansicht sehen. 




\pagebreak

\section{Verlauf}

Der Verlauf ist eine einfache Liste von den ganzen Bestellungen des Users.
Es wird der Menüname, das Bestelldatum und das Datum des Menüs angezeigt.
Ist die Bestellung stornierbar, so wird eine Mülltonne als Icon angezeigt. 
Durchs draufklicken auf die Mülltonne, wird die Bestellung storniert.

\begin{figure}[htp]
    \centering
    \author{Bozidar Spasenovic}
    \includegraphics[scale=0.09]{pics/VerlaufAndroid.png}
    \caption{VerlaufAndroid Android}
    \label{fig:impl:VerlaufAndroid}
\end{figure}


Es wird ein PUT auf die URL http://10.0.2.2:8080/menue/bestellung?id=\$menuId was im backend das löschen zur jeweiligen Menü Id ausübt.
Falls ein erfolgreicher Response zurückkommt, so wird die InitBestellungen()-Methode zum neu laden des Verlaufes aufgerufen.

\begin{lstlisting}
    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            e.printStackTrace()
        }

        override fun onResponse(call: Call, response: Response) {
            response.use {
                if (!response.isSuccessful){
                    throw IOException("Unexpected code $response")
                }

                InitBestellungen(currUser.value)
            }
        }
    })
\end{lstlisting}


\pagebreak


\section{Bestellansicht}

In der Bestellansicht werden die Felder Menü, Von und das Datum automatisch in ein Readonly Text Field gespeichert.
Man kann dann die Anzahl angeben, für wen man es bestellen möchte und auch zwischen vier Zeiten aussuchen. 

\begin{figure}[htp]
    \centering
    \author{Bozidar Spasenovic}
    \includegraphics[scale=0.09]{pics/BestellübersichtAndroid.png}
    \caption{Bestellansicht Android}
    \label{fig:impl:BestellübersichtAndroid}
\end{figure}

\subsection{postBestellung()}
Nach dem Abschließen wird die postBestellung()-Methode aufgerufen. Sie erstellt einen Requestbody mit den eingegebenen Werten
und schickt es mittels POST an die "http://10.0.2.2:8080/menue/bestellung/" URL. Dieser Endpoint führt dann die Anfrage durch und schickt einen Response zurück.
Wichtig dabei ist es den richtigen Media-Type zu definieren. 

Die Anfrage und Antwort:
\begin{lstlisting}
    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            e.printStackTrace()
        }

        override fun onResponse(call: Call, response: Response) {
            response.use {
                if (!response.isSuccessful) throw IOException("Unexpected code $response")

                val gson = GsonBuilder().create()

                val collectionType: Type =
                    object : TypeToken<Collection<Bestellung?>?>() {}.type
                bestellungen = gson.fromJson(response.body!!.string(), collectionType)
            }
        }
    })
\end{lstlisting}

Der Response wird so benutzt, dass man als erstes mit dem GsonBuilder ein Gson-Objekt erstellt.
Dieses Objekt wird verwendet um ein JSON-Objekt in ein Kotlin-Objekt umzuwandeln. 
Damit man Gson verwendetn kann, benötigt man die abhängigkeit com.google.code.gson:gson:2.8.9.
abschliesend wird vom Responsebody eine Collection von allen mitgegebenen Bestellungen erstellt und gespeichert.


