\section {Systemarchitektur}
\author{Benjamin Besic}

\begin{figure}[htp]
    \centering
    \author{David Ignjatovic}
    \includegraphics[scale=0.7]{pics/final-sys-arc.PNG}
    \caption{Systemarchitektur des Programms}
    \label{fig:impl:SysArc}
\end{figure}

Der Systemarchitektur kann man entnehmen, dass das Quarkus Backend die zentrale Stelle für alle anderen Technologien bildet.
Das Backend stellt mit Hilfe der Datenbank alle Daten zur Verfügung mittels REST. \\*
Der Keycloak Server sichert die beiden Frontends ab und sorgt dafür, dass keine ungewollten Zugriffe entstehen.
Vue.js benützt dafür ein Keycloak Package, dass eine leichte Integration erlaubt. Die Android App hingegen arbeitet mittels REST Requests mit Keycloak zusammen,
da es zum jetzigen Zeitpunkt keine offizielle Erweiterung für Jetpack Compose gibt.

\subsection{Technologien}

Beim Entwickeln wurden folgende Technologien verwendet:
\begin{itemize}
    \item docker 3.1
    \item Vue.js 2.6.14
    \item quarkus 2.5.0.Final
    \item Jetpack Compose 1.0.1
    \item Keycloak 14.0.0
    \item Java OpenJDK-11
    \item Java EE 8
    \item JBoss Wildfly 7.3.4.GA
\end{itemize}

\section{Datenmodell}
\author{David Ignjatovic}

Ein Datenmodell wird als Darstellung der relevanten Objekte eines Projektes verwendet. 

\subsection{Use Cases}

\subsubsection{Kantinenarbeiter}

\begin{compactitem}
    \item Neue Menüs anlegen
    \begin{compactitem}
        \item Kantinenmitarbeitende können für jeden Tag neue Menüs mit drei Hauptspeisen und deren Kategorien, einer Vorspeise und einer Nachspeise anlegen.
    \end{compactitem}
    \item Vorhandene Menüs editieren
    \begin{compactitem}
        \item Die Bezeichnungen der bereits erstellten Menüs sollen verändert werden können.
    \end{compactitem}
    \item Übersicht der täglichen Bestellungen
    \begin{compactitem}
        \item Die Kantinenmitarbeitenden sollen eine Übersicht, der an einem bestimmten Tag bestellten Menüs haben. Diese inkludiert die zusammengefasste Bestellanzahl der verschiedenen Menüs und eine Liste von allen Bestellungen.
    \end{compactitem}
    \item Bestellungsübersicht drucken
    \begin{compactitem}
        \item Die Übersicht wie vorher beschrieben soll zu einem PDF-Objekt konvertiert werden und dementsprechend ausgedruckt werden können.
    \end{compactitem}
\end{compactitem}

\subsubsection{Mitarbeiter}

\begin{compactitem}
    \item Menüs bestellen
    \begin{compactitem}
        \item Ein Mitarbeiter hat eine Auswahl aller Menüs und kann für jeden Tag eine der drei Hauptspeisen auswählen. Nach der Auswahl kann er die Essenszeit auswählen, die Anzahl und nötige Kommentare hinzufügen.
    \end{compactitem}
    \item Menüs für andere Mitarbeiter bestellen
    \begin{compactitem}
        \item Ein Mitarbeiter kann den obrigen Bestellvorgang für einen anderen Mitarbeiter ausführen. 
    \end{compactitem}
    \item Übersicht aller Bestellungen
    \begin{compactitem}
        \item Als Mitarbeiter soll man alle seine vergangenen Bestellungen und deren Informationen in einer Übersicht einsehen können. Diese Übersicht kann filtriert werden.
    \end{compactitem}
    \item Bestellungen stornieren
    \begin{compactitem}
        \item In der oben genannten Übersicht soll man die Möglichkeit haben eine Bestellung auszuwählen und zu stornieren, wenn dies möglich ist.
    \end{compactitem}
    \item Bestellstatistiken einsehen
    \begin{compactitem}
        \item Ein Mitarbeiter soll Diagramme zur Verfügung haben, wo er sein Bestellverhalten einsehen kann.
    \end{compactitem}
\end{compactitem}

\subsection{Planung}
\author{Benjamin Besic}
Einer der ersten Arbeitsschritte war die Entwicklung eines Datenmodells, welches die Basis der Programmlogik sein soll. Dieses wurde mittels einem ERD-Diagramm visualisiert.


Die erste Version wurde von unserem Team entwickelt, aus den Erfahrungen und Informationen, die wir im Unterricht gesammelt haben. \\*
An dieser Version merkt man, dass die meisten Teile in einzelne Tabellen aufgeteilt wurden. Dies sorgt für Flexibilität und Wiederverwendung von einem Menü, da die einzelnen
Speisen aufgeteilt sind.
Am Anfang war geplant, dass jede Speise auch ein Bild hat, damit der Mitarbeiter weiß, wie die Speise auch wirklich aussieht.\\*
Ebenfalls erkennt man, dass es eine User-Klasse gibt, da Mitarbeiter, Personal und Kantine gleiche Eigenschaften miteinander teilen wie zum Beispiel Vor- und Nachname.\\* \pagebreak

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.6]{pics/erd-alt.png}
    \caption{Erste Version des Datenmodells}
    \label{fig:impl:ERDold}
\end{figure}

Die zweite Version des Datenmodells übernimmt das Meiste der ersten Version, jedoch wurde es nach Absprache mit unserer Partnerfirma überarbeitet, um deren Anforderungen mehr zu entsprechen.\\*
Eine wichtige Änderung ist, dass die Menue-Klasse alle Speisen enthält und diese als einfacher Text gespeichert werden. Der Grund dafür ist, dass die Kantine
immer die Menüs händisch eingibt und eine Auswahl von vorhandenen Speisen würde nur den Speicheraufwand unnötig erhöhen. Es kommt eher selten vor, dass die selben Speisen nacheinander kommen.\\*
Was vorher gefehlt hat, war der Kommentar und die Möglichkeit die Stornierung eines Menüs nachzuvollziehen. Wenn ein Menü storniert wird, wird es nicht gelöscht, sondern es wird nur 
das Stornodatum gesetzt. Es ist wichtig, dass auch stornierte Bestellungen in der Datenbank bleiben. \\*
Ebenfalls wurde die Abrechnung eines Menüs in der ersten Version nicht berücksichtigt. Die Kosten für das Menü werden dem Mitarbeiter vom Gehalt abgezogen und dies erfolgt anhand 
von den Daten in der Datenbank.
Die Benutzertabellen sind noch leer, da zu dem Zeitpunkt noch nicht feststand ob diese Tabellen wirklich benutzt werden sollen, da es bereits eine Datenbank für Mitarbeiter gab in der Firma.  \pagebreak

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.6]{pics/erd-aktuell.png}
    \caption{Zweite Version des Datenmodells}
    \label{fig:impl:ERDSecond}
\end{figure}

In der finalen Version wurde entschieden auf die Benutzertabellen zu verzichten, da die Mitarbeiter mittels Keycloak ihre Anmeldedaten übermitteln. Daher reicht auch nur die Personalnummer
in der Bestellung-Tabelle. Der Menue-Tabelle wurde ein Kategorien-Attribut hinzufügt. Dies dient dazu, um jedes Menü in bestimmte Kategorien einzuteilen. Ebenfalls zu erkennen sind neue Felder 
wie ``GEANDERTUM'' oder ``ANGELEGTVON''. Diese wurden ergänzt, um Logdaten direkt in der Tabelle einsehen zu können. Die Felder werden automatisch ausgefüllt, nachdem 
eine Transaktion auf die Tabellen erfolgt.

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.5]{pics/erd.jpeg}
    \caption{Finale Version des Datenmodells}
    \label{fig:impl:ERDFinal}
\end{figure}

\pagebreak

\subsection{Entitäten}
\author{David Ignjatovic}

Eine Entität ist ein bestimmtes Objekt mit den jeweiligen Atributen. Atribute sind die Eigenschaften eins Objektes.
Unser Projektes beinhaltet 5 Entitäten:

\begin{itemize}
  \item Bestellung
  \item Categories
  \item Kantine
  \item Menue
  \item Oeffungszeit
\end{itemize}

\subsection{Bestellung} 

Die Entität \textbf{Bestellung} enthält die wichtigsten Informationen über einen Mitarbeiter und die dazu ausgewählte Mahlzeit.
Zur Identifikation einer Bestellung verwenden wir eine Id welche generiert wird. \\*

In der Bestellung wird angegeben von wem die Bestellung bestellt wurde und ob der Mitarbeiter es auch für sich selbst bestellt hat oder für jemand anderen. 
Jeder Mitarbeiter der Firma hat auch eine Personalnummer. Bei jeder Bestellung gibt es die Möglichkeit einen Kommentar abzugeben. Dieser wird an die Kantine mitgegeben. Natürlich hat man auch die Möglichkeit 
eine Mahlzeit öfters zu bestellen. Somit hat jeder Mitarbeiter die Möglichkeit eine Bestellanzahl mitzugeben. Für das Bestellen, Bearbeiten aber auch das Stornieren wird immer die jetzige Uhrzeit mitgegeben. \\*

Das wichtigste in der Bestellung ist die Mahlzeit und für wann es bestellt wurde. Dafür verwenden wir die zwei Klassen, Oeffnungszeit und Menue. \\*


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\subsection{Categories}

Die Entität \textbf{Categories} ist ein Enum, welches wir hauptsächlich für unseren Algorithmus verwenden. Es besteht aus 4 Einträgen: \\*


\begin{itemize}
    \item Vegetarisch
    \item Vegan
    \item Schwein
    \item Rind
    \item Huhn
    \item Pute
    \item Salat
    \item Nudel
    \item Süß
    \item Fisch
    \item Sonstiges
\end{itemize}

Die einzelnen Kategorien beschreiben eine Mahlzeit. Sommit kann man ganz einfach zwischen einzelnen Mahlzeiten unterscheiden und sie auch gruppieren.


\subsection{Kantine}

In der Entitäten \textbf{Kantine} befinden sich die wichtigsten Informationen über eine Kantine wie zum Beispiel ob eine Kantine offen hat oder zurzeit geschlossen ist. 
Eine kleine Beschreibung über die Kantine und über das Service ist ebenso enthalten. \\*

\subsection{Menue}

In der Entität \textbf{Menue} stehen die wichtigsten Informationen über ein Menü. Ein Menü beinhaltet eine Vorspeise, Hauptspeise, Nachspeise und ein Dessert. 
Noch dazu findet man in der Entität ein Datum, um zuzuordnen wann das Menü bestellt worden ist. \\*

Neben dem Bestelldatum beinhaltet die Entität Menue auch noch weitere Timestamps.
Die verwendeten Timestamps werden verwendet, um zu speichern, wann ein Menü erstellt wurde oder wann ein Menü geändert wurde. 
Natürlich wird auch mitgespeichert, von wem diese Änderungen durchgeführt worden sind. \\*


Die bereits oben genannten Kategorien finden wir in der Entität \textbf{Menue}. 
Diese werden verwendet, um einzelne Menüs zu unterscheiden und mit Hilfe der Kategorien und unserem Algorithmus kann man einfach hervorwagen welche Mahlzeit zu welchem Mitarbeiter am besten passt. \\*

Für jedes Menü wird auch die dazu ausgewählte Kantine mitgespeichert. So weiß man, zu welcher Kantine der Mitarbeiter gehen muss, um sein Menü zu bekommen. \\*



\subsection{Oeffnungszeit}

Die Entitäten \textbf{Oeffnungszeit} zeigt an, ob ein Kantinenraum in Verwendung ist und ob die maximale Anzahl an Sitzplätzen schon belegt ist. 
Das Zeitfenster, welches beschreibt wann gegessen wird, wird ebenso mitgespeichert. \\*

Um zu wissen, welcher Kantinenraum gemeint wird, wird auch die verwendete Kantine mitgespeichert. \\*

\section{REST-Schnittstellen}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\subsection{Allgemein}

In den folgenden Beispielen läuft unser Server lokal auf dem Port 8080. Die URL über die unser
Server erreicht werden kann, lautet: \textbf{\textit{http://localhost:8080/menue}}.

Wir verwenden 13 Endpoints:

\subsubsection{Bestellung}

\begin{tabular}{|p{3cm}|p{6cm}|p{5cm}|}
    \hline
    Typ & Path & Info\\
    \hline
    GET & /bestellung/{username} & Bestellungen von einem Mitarbeiter\\
    \hline
    GET & /bestellung/stats/{username} & Anzahl der Bestellungen pro Wochentag eines Mitarbeitern\\
    \hline
    GET & /bestellung/categories & Alle Kategorien\\
    \hline
    GET & /bestellung/categories/{username} & Alle Kategorien von einem bestimmten Mitarbeiter\\
    \hline
    GET & /bestellung?date=datum & Alle Bestellungen an einem bestimmten Tag\\
    \hline
    POST & /menue/bestellung & Bestellung erstellen\\
    \hline
    POST & /menue/bestellung & Bestellung stornieren\\
    \hline
\end{tabular}

\subsubsection{Menue}

\begin{tabular}{|p{3cm}|p{6cm}|p{5cm}|}
    \hline
    Typ & Path & Info \\
    \hline
    GET & /menues/menues & Alle Menüs\\
    \hline
    POST & /menues/menues & Menü erstellen\\
    \hline
    POST & /menues/menues & Menü verändern\\
    \hline
    GET & /menue/menues/recommendation & Menü-Vorschlag (Recommendation)\\
    \hline
    GET & /menues/menues/<date> & Alle Menüs an einem bestimmten Tag\\
    \hline
\end{tabular}

\subsubsection{Öffnungszeiten}

\begin{tabular}{|p{3cm}|p{6cm}|p{5cm}|}
    \hline
    Typ & Path & Info\\
    \hline
    GET & /menues/oeffnungszeiten & Alle aktiven Essenszeiten\\
    \hline
\end{tabular}

\subsection{Bestellung}

\subsubsection{Bestellungen von einem Mitarbeiter}

Um zu sehen welche Bestellungen ein Mitarbeiter hat, muss der Pfad \textbf{\textit{/bestellung/<username>}} aufgerufen werden. 
Hierbei handelt es sich um eine GET-Methode die mittels Path Parameter die Bestellungen eines bestimmten Mitarbeiters zurück gibt.
Wenn ein Mitarbeiter gefunden wurde und dieser auch mindestens eine Bestellung hat wird der Status 200 zurückgegeben. \\*

Das Reslutat für den Mitarbeiter \textbf{spabo} sieht folgendermassen aus:


URL: GET \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]| http://localhost:8080/menue/bestellung/spabo|}


Output:

\begin{lstlisting}[language=json,firstnumber=1]
{
    "createdAt": "2021-11-26T15:33:33.62898Z[UTC]",
    "id": 1315,
    "menueDate": "2021-11-29",
    "menueName": "Spaghetti",
    "orderedFor": "spabo",
    "timeWindow": "11:15 - 11:45"
}
\end{lstlisting}

Die Bestellungen wird nach dem Datum, an dem eine Bestellungen angelegt wurde, sortiert. Somit werden immer die neusten Bestellungen gleich am Anfgang angezeigt.


\subsubsection{Anzahl der Bestellungen pro Wochentag eines Mitarbeitern}

Wenn man sehen will, wie oft ein Mitarbeiter pro Wochentag ein Menue bestellt hat, muss der Pfad \textbf{\textit{/bestellung/stats/<username>}} aufgerufen werden.
Es werden alle Wochentage angezeigt an denen ein Mitarbeiter eine Bestellung getätigt hat. Wenn mindestens ein Wochentag mit einer Bestellung zur verfügung steht, 
wird der Status 200 zurückgegeben.

Das Reslutat für den Mitarbeiter \textbf{besbe} sieht folgendermassen aus:


URL: GET \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]|http://localhost:8080/menue/bestellung/stats/besbe|}


Output:

\begin{lstlisting}[language=json,firstnumber=1]
[
    {
    "amount": 2,
    "weekday": "Montag"
    },
    {
    "amount": 1,
    "weekday": "Mittwoch"
    },
    {
    "amount": 1,
    "weekday": "Donnerstag"
    },
    {
    "amount": 0,
    "weekday": "Dienstag"
    }
]
\end{lstlisting}

\pagebreak

\subsubsection{Alle Kategorien}

Damit man alle Kategorien sehen kann, die eine Mahlzeit beschreibt, muss der Pfad  \textbf{\textit{/bestellung/categories}} aufgerufen werden.
Wichtig ist es, dass man hier keinen Namen als Parameter übergibt. \\*

Anhand der Kategorien, wird mit Hilfe eines Algorithmus enschieden, welche Mahlzeit am besten zu einem Mitarbeiter passt. Es wird darauf geschaut, welche Kategorie
am häufigsten vorkommt.

Die verwendbaren Kategorien sehen folgendermassen aus:

URL: GET \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]|http://localhost:8080/menue/bestellung/categories|}

Output:

\begin{lstlisting}[language=json,firstnumber=1]
[
    "Vegetarisch",
    "Vegan",
    "Schwein",
    "Rind",
    "Huhn",
    "Pute",
    "Salat",
    "Nudel"
    "Fisch",
    "Sonstiges"
]
\end{lstlisting}

Das wird hauptsächlich verwendet, um bei dem Frontend alle Kategorien anzuzeigen die für eine bestimmte Mahlezeit dazugehören.

\pagebreak

\subsubsection{Alle Kategorien von einem bestimmten Mitarbeiter}

Um zu sehen welche Kategorien ein Mitarbeiter bestellt hat, muss der Pfad \textbf{\textit{/bestellung/categories/<username>}} aufgerufen werden.

Wenn ein User keine Bestellungen getätigt hat, werden auch keine Kategorien zurückgegeben. In dem folgenden Beispiel kann man aber sehen, wie das Reslutat
für den Mitarbeiter \textbf{spabo} aussieht:

URL: GET \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]|http://localhost:8080/menue/bestellung/categories/spabo|}

Output:

\begin{lstlisting}[language=json,firstnumber=1]
[
    "Vegetarisch",
    "Nudel",
    "Vegan",
    "Schwein",
    "Salat",
    "Pute"
]
\end{lstlisting}

\subsubsection{Alle Bestellungen an einem bestimmten Tag}

Damit die Kantine sehen kann, welche Bestellungen an welchen Tagen zugewissen worden sind, muss der Pfad \textbf{\textit{/bestellung?date=datum}} aufgerufen werden.

Es kann aber auch sein, das es an bestimmten Tagen keine Bestellungen gibt. Deshalb werden auch keine Ergebnisse zurückgegeben.

Um aber zu veranschaulichen, wie manche Bestellungen an einem bestimmten Zeitpunkt zurückgegeben werden, verwenden wir das den \textbf{16.03.2022}.

\pagebreak

URL: GET \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]|http://localhost:8080/menue/bestellung?date=2022-03-16|}

Output:

\begin{lstlisting}[language=json,firstnumber=1]
[
    {
        "code": "A",
        "date": "2022-03-16",
        "menue": "Schnitzel",
        "menueCounter": 1,
        "orderedFor": "spabo",
        "personalNumber": 1023,
        "timewindow": "11:15 - 11:45"
    },
    {
        "code": "C",
        "date": "2022-03-16",
        "menue": "Eisbergsalat",
        "menueCounter": 1,
        "orderedFor": "spabo",
        "personalNumber": 1023,
        "timewindow": "12:00 - 12:30"
    },
    ...
    ]
\end{lstlisting}


\subsubsection{Bestellung erstellen}

Wenn ein User eine Bestellung aufgeben will, muss der Pfad \textbf{\textit{/menue/bestellung}} aufgerufen werden. 
Mithilfe der id, die man von dem vorherigen Request bekommen hat, kann man ganz einfach seine Bestellung abgeben. \\*

Ein Beispiel für eine Bestellung sieht folgendermassen aus:

\begin{lstlisting}[language=json,firstnumber=1]
    {
        "orderedBy":"spabo",
        "amount":"1",
        "comment":"",
        "menueId":707,
        "orderedFor":"spabo",
        "timeId":6,
        "personalNummer":1023
    }
\end{lstlisting}

Wenn die Betellung erfolgreich war, wird der Status 200 zurückgegeben.


\subsubsection{Bestellung stornieren}

Um eine Betellung zu stornieren, muss der Pfad \textbf{\textit{/menue/bestellung}} aufgerufen werden. Wie auch bei dem Erstellen einer Bestellung wird 
mit Hilfe einer id die Bestellung zugeordnet. \\*

In unserer Datenbank wird die Bestellung nicht direkt gelöscht sondern überschrieben. Sie wird also auf gelöscht gesetzt, jedoch nicht aus der Datenbank gelöscht.

Wenn die Bestellung erfolgreich storniert wurde, wird die Antwort \textit{Order with id <is> was cancelled!} zurückgegeben.

\subsection{Menue}

\subsubsection{Alle Menüs}

Um sehen zu können, welche Menüs es überhapt schon gab, muss der Pfad \textbf{\textit{/menues/menues}} aufgerufen werden. 

Ein Beispiel für ein Menue sieht folgendermassen aus:

URL: GET \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]|http://localhost:8080/menue/menues|}


\begin{lstlisting}[language=json,firstnumber=1]
[
    {
        "appetizer": "Suppe",
        "categories": "Vegan;Vegetarisch;Salat",
        "code": "C",
        "date": "2022-03-22",
        "dessert": "Milka",
        "id": 706,
        "mainDish": "Kartofell Salat"
    },
    {
        "appetizer": "Suppe",
        "categories": "Vegan;Vegetarisch;Salat",
        "code": "C",
        "date": "2022-03-22",
        "dessert": "Milka",
        "id": 705,
        "mainDish": "Kartofell Salat"
    },
    ...
]
\end{lstlisting}

\subsubsection{Menü erstellen}

Damit die Kantine ein Menü erstellen kann, wird ein POST-Request an den Pfad \textbf{\textit{/menue/menues}} geschickt.

Da eine Bestellung aus genau 3 Menues besteht, werden auch 3 POST-Requests abgeschickt. Die werte werden in Form eines JSON Objekt abgeschickt.

Ein Beispiel für eine Bestellung sieht folgendermassen aus:

URL: POST \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]|http://localhost:8080/menue/menues/|}


JSON Objekt für Menue A:

\begin{lstlisting}[language=json,firstnumber=1]
{
    "id":null,
    "date":"2022-03-22",
    "code":"A",
    "appetizer":"Suppe",
    "mainDish":"Pasta",
    "dessert":"Milka",
    "categories":"Rind;Nudel"
}
\end{lstlisting}

JSON Objekt für Menue B:

\begin{lstlisting}[language=json,firstnumber=1]
{
    "id":null,
    "date":"2022-03-22",
    "code":"B",
    "appetizer":"Suppe",
    "mainDish":"Lachs",
    "dessert":"Milka",
    "categories":"Fisch"
}
\end{lstlisting}

JSON Objekt für Menue C:

\begin{lstlisting}[language=json,firstnumber=1]
{
    "id":null,
    "date":"2022-03-22",
    "code":"C",
    "appetizer":"Suppe",
    "mainDish":"Kartofell Salat",
    "dessert":"Milka",
    "categories":"Vegan;Vegetarisch;Salat"
}
\end{lstlisting}

Wie man sehen kann, werden die Kategorien in einem String übergeben. Die Kategorien werden dann getrennt und als Enum gespeichert.

\subsubsection{Menü verändern}

Wie auch bei dem Erstellen eines Menüs, wird der Pfad \textbf{\textit{/menue/menues}} aufgerufen. 
Wie schon erwähnt, besteht eine Bestellung aus genau 3 Menüs, deswegen werden auch 3 PUT-Requests abgeschickt.

Ein Beispiel für eine Bestellung sieht folgendermassen aus:

URL: PUT \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]|http://localhost:8080/menue/menues/|}

JSON Objekt für Menue A:

\begin{lstlisting}[language=json,firstnumber=1]
{
    "id":null,
    "date":"2022-03-22",
    "code":"A",
    "appetizer":"Suppe",
    "mainDish":"Pasta",
    "dessert":"Milka",
    "categories":"Rind;Nudel"
}
\end{lstlisting}

JSON Objekt für Menue B:

\begin{lstlisting}[language=json,firstnumber=1]
{
    "id":null,
    "date":"2022-03-22",
    "code":"B",
    "appetizer":"Suppe",
    "mainDish":"Lachs",
    "dessert":"Milka",
    "categories":"Fisch"
}
\end{lstlisting}

JSON Objekt für Menue C:

\begin{lstlisting}[language=json,firstnumber=1]
{
    "id":null,
    "date":"2022-03-22",
    "code":"C",
    "appetizer":"Suppe",
    "mainDish":"Kartofell Salat",
    "dessert":"Milka",
    "categories":"Vegan;Vegetarisch;Salat"
}
\end{lstlisting}


\subsubsection{Menü-Vorschlag (Recommendation)}

Wenn ein Mitarbeiter nicht weiß, welche Mahlezeit er wählen soll, wird mithilfe eines Recommender entschieden, welche Mahlzeit am besten dem 
User passt.  

Um die passende Mahlezeit zu bekommen, muss der Pfad \textbf{\textit{/menue/menues/recommendation}} aufgerufen werden.

Der Algorithmus sieht folgendermassen aus:

URL: PUT \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]|http://localhost:8080/menue/menues/recommendation|}

\begin{lstlisting}
    public Menue  getRecommendation(String name, String date){
        List<String> categories = bestellungRepository.getALlCategoriesByUsername(name);
        List<Menue> menues = getMenuesByDate(date);
        Menue recommendedMenue = null;

        for (String category : categories){
            if(recommendedMenue != null){
                break;
            }
            for (Menue m : menues){
                if(recommendedMenue != null){
                    break;
                }

                String[] categorieOfMenue = m.getCategories().split(";");

                for (String c : categorieOfMenue){
                    if (category.equals(c)){
                        recommendedMenue = m ;
                        break;
                    }
                }
            }
        }
        return recommendedMenue;
    }
\end{lstlisting}

\pagebreak

Um herausfinden zu können welche Mahlzeit optimal wäre, werden mit Hilfe des Algorithmus alle Kategorien des Users aus der Datenbank gehollt. 
Jeder User der eine Bestellung getätigt hat, hatte die höglichkeit zu sehen, welche Kategorien die Mahlzeit auch besitzt. Sommit kann man leicht herauszufinden
welche Kategorien auch am häufigsten in der Bestellhistorie vorkommen. \\*

Unser Algorithmus würde nicht funktionieren, gäbe es keine Bestellungen oder Mahlzeiten würden keine Kategorien besitzten. 
In anderen Worten, desto mehr Bestellungen man hat, umso genauer wird die recommendation. \\*

Die Kategorien werden in der Datenbank als string gespeichert die mit einem Strichpunkt geteilt werden. Hat man also bei einer Mahlzeit mehr als eine Kategorie,
so wird dieser als string mit einem oder mehreren Strichpunkten gespeichert. \\*


Hier ein paar Beispiele:

\textit{Schnitzel mit Pommes} = \textbf{Schwein}

\textit{Eisbergsalat} = \textbf{Vegan;Vegetarisch}

\textit{Nudelsalat mit Hühnerfleisch} = \textbf{Nudel;Salat;Huhn}

\subsubsection{Alle Menüs an einem bestimmten Tag}

Um alle Menüs an einem bestimmten Tag zu bekommen, wird der Pfad \textbf{\textit{/menue/menues/<date>}} aufgerufen.

Ein Beispiel für paar Menüs, welche am 12.08.2021 bestellt worden sind, sieht folgendermassen aus:

URL: PUT \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]|http://localhost:8080/menue/menues/2021-12-08|}

\pagebreak

\begin{lstlisting}[language=json,firstnumber=1]
{
    [
        {
            "appetizer": "Nudelsuppe",
            "categories": "Schwein",
            "changedAt": "2021-12-07T19:29:08.840936Z[UTC]",
            "changedBy": "IF170009:IF170009:beni",
            "code": "A",
            "createdAt": "2021-12-07T18:37:30.322514Z[UTC]",
            "createdBy": "IF170009:beni",
            "date": "2021-12-08",
            "desert": "Obst",
            "id": 499,
            "kantine": {
            "canteenDesc": "Betriebskueche",
            "changedAt": "2021-11-25T21:29:47.471379Z[UTC]",
            "changedBy": "IF170009:beni",
            "createdAt": "2021-11-25T21:29:47.471196Z[UTC]",
            "createdBy": "IF170009:beni",
            "id": 3,
            "serviceDesc": "Mittagstisch - CORONA LIGHT",
            "status": "A"
            },
            "mainDish": "Schweineschnitzel"
        },
        {
            "appetizer": "Nudelsuppe",
            "categories": "Rind;Nudel",
            "changedAt": "2021-12-07T19:29:08.995487Z[UTC]",
            "changedBy": "IF170009:IF170009:beni",
            "code": "B",
            "createdAt": "2021-12-07T18:37:30.490055Z[UTC]",
            "createdBy": "IF170009:beni",
            "date": "2021-12-08",
            "desert": "Obst",
            "id": 500,
            "kantine": {
            "canteenDesc": "Betriebskueche",
            "changedAt": "2021-11-25T21:29:47.471379Z[UTC]",
            "changedBy": "IF170009:beni",
            "createdAt": "2021-11-25T21:29:47.471196Z[UTC]",
            "createdBy": "IF170009:beni",
            "id": 3,
            "serviceDesc": "Mittagstisch - CORONA LIGHT",
            "status": "A"
            },
            "mainDish": "Lasagne"
        },
        ...
    ]
}
\end{lstlisting}

Hier sieht man die wichtigsten Daten wie zum Beispiel die Vorspeise, Hauptspeise, Nachspeise und Desert welche von dem jeweiligem Mitarbeiter bestellt worden sind. 
Auch Daten wie die Bestellzeit und in welcher Kantine gegessen wird wird auch mitgegeben.

\subsection{Öffnungszeiten}

\subsubsection{Alle aktiven Essenszeiten}

Um zu sehen ob noch freie Sitzplätze zur Verfügung stehen, wird der Pfad \textbf{\textit{/menue/oeffnungszeiten}} aufgerufen. 

In unserer Kantine gibt es 4 Zeiten an denen man essen gehen kann. Diese dauern immer eine halbe Stunde und haben eine Zwischenpause von 15 min. 
Pro Essenszeit können maximal 20 Personen in dem Saal essen.

Ein Beispiel für die Öffnungszeiten und für die freien Plätze sieht folgendermassen aus:

URL: PUT \colorbox{white}{\lstinline[basicstyle=\ttfamily\color{black},language=html]|http://localhost:8080/menue/menues/2021-12-08|}


\begin{lstlisting}[language=json,firstnumber=1]
{
    [
        {
            "chosen": false,
            "freeSeats": -1,
            "id": 6,
            "maxSeats": 20,
            "time": "11:15 - 11:45"
        },
        {
            "chosen": false,
            "freeSeats": -1,
            "id": 7,
            "maxSeats": 20,
            "time": "12:00 - 12:30"
        },
        {
            "chosen": false,
            "freeSeats": -1,
            "id": 8,
            "maxSeats": 20,
            "time": "12:45 - 13:15"
        },
        {
            "chosen": false,
            "freeSeats": -1,
            "id": 9,
            "maxSeats": 20,
            "time": "13:30 - 14:00"
        }
    ]
}
\end{lstlisting}

\section{Authentifizierung}

\section {Interface Webapp}
\author{Benjamin Besic}
\subsection{Planung}

Nachdem das Datenmodell feststand wurden UI-Prototypen entwickelt, die das Aussehen der Vue-App darstellen sollen.

\begin{figure}[htp]
    \author{Benjamin Besic}
    \centering
    \includegraphics[scale=0.3]{pics/UI-Bestellung-Prototyp.png}
    \caption{UI-Prototypen für den Bestellvorgang}
    \label{fig:impl:UIPlanningBest}
\end{figure}

\subsubsection{Bestellvorgang}
Beim Entwickeln stehen die Benutzerfreundlichkeit und das Aussehen auf mobilen Geräten an erster Stelle. Anhand dessen ist die Navigationsleiste am Wichtigsten.
Diese soll den Benutzer auf alle Sichten führen können und dem Benutzer ermöglichen, sich auszuloggen. \\*
Der Kalender muss übersichtlich sein und die Tage, an denen Bestellungen nicht möglich sind, sollten ausgeblendet sein. Ebenfalls soll auch in die Vergangenheit gesehen werden können.\\*
Um den Rest des Platzes auszunutzen wurde eine Menüauswahlt geplant, die so viel Informationen wie möglich  darstellen kann, ohne den Benutzer zu überfordern.
Nach langem Überlegen wurden die drei Menüs groß als Kästen dargestellt, um soviel wie möglich innerhalb dieser darstellen zu können.
Die Vor- und Nachspeise ist kleiner dargestellt, da man keine Entscheidung darüber machen kann.\\*
Die Sicht nachdem man sich ein Menü ausgewählt hat, soll so kompakt wie möglich sein, da auch die mobile Ansicht ohne Probleme nutzbar sein soll.
Alle Informationen, die vom Benutzer eingegeben werden müssen, sollen in der Form eines Formulars angezeigt werden und andere Informationen wie Ersteller und Gericht 
werden automatisch eingesetzt.
\begin{figure}[htp]
    \author{Benjamin Besic}
    \centering
    \includegraphics[scale=0.36]{pics/UI-Login-Uebersicht-Prototyp.png}
    \caption{UI-Prototypen für den den Login und die Übersicht}
    \label{fig:impl:UIPlanningLogUebersicht}
\end{figure}

\subsubsection{Login und Übersicht}
Der Login soll einladend sein, hat aber keinen besonderen Anforderungen zu entsprechen \\*
Die Übersicht über die bereits bestellten Menüs soll dem Benutzer alle wichtigen Informationen auf einen Blick geben.
Das Stornieren soll ebenfalls simpel gehalten werden, damit der Benutzer nicht darüber nachdenken muss.
Der Benutzer soll auch eine Möglichkeit haben die Bestellungen zu filtern, um bestimmte Zeitpunkte bzw. Menüs einfacher zu finden.


\subsection{Login}
Beim Aufrufen der Webapp wird man zunächst zu der Login-Seite weitergeleitet. Wie diese ausschaut, sieht man in der nächsten Abbildung. \\*
Der Login dient in erster Hinsicht dazu, um festzustellen ob der Benutzer ein Mitarbeiter oder Kantinenmitarbeiter ist.
Denn nach dem Login wird man entweder zur Mitarbeiter-Ansicht oder Kantinenmitarbeiter-Ansicht weitergeleitet. \\*

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.3]{pics/login_screen_vue.JPG}
    \caption{Login Screen}
    \label{fig:impl:LoginVue}
\end{figure}


\pagebreak

\subsection {Mitarbeiter-Ansicht}
\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.125]{pics/activity-mitarbeiter.png}
    \caption{Die wichtigsten Aktivitäten der Mitarbeitenden}
    \label{fig:impl:ActEmployee}
\end{figure}

\subsubsection {Home}
\label{sec:MitHome}
Das Erste, was ein Mitarbeiter zu sehen bekommt, ist die Home Ansicht. In dieser Ansicht ist eine Kalender und die Menüauswahl enthalten. \\*
Der Benutzer kann im Kalender das gewünschte Bestelldatum anklicken, dadurch wird automatisch die Menüauswahl aktualisiert. Man kann sich in die Zukunft, sowohl auch 
in die Vergangenheit klicken, um sich Auskunft über die vergangenen/kommenden Menüs zu beschaffen. Die Ansicht ist nur auf die Bestelltage beschränkt, an denen Menüs angeboten werden.\\*
Nach der erfolgreichen Datumswahl hat man unten drei Menüs zur Auswahl, dabei steht auch die dazugehörige Vor- und Nachspeise. Das dem Benutzer empfohlene Menü (Analyse aus seinem Bestellverlauf) wird grün hinterlegt.
Neben den Bestellköpfen befindet sich ein Fragezeichen-Knopf, wenn man über diesen geht werden einem die Kategorien des Menüs angezeigt.
\\* Wenn die Bedingungen für eine Bestellung erfüllt sind,
kann man auf einen der drei Bestellknöpfe drücken, um zur Bestellansicht weitergeleitet zu werden. Sind diese Bedingungen nicht erfüllt, sind die Knöpfe ausgeschaltet. \\*
Weiters werden unter den Menüs noch relevante Informationen angezeigt. Durch das Klicken des Fragezeichen-Knopfs wird ein Bild der 14 Allergene geöffnet.

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.35]{pics/mitarbeiter-home.JPG}
    \caption{Home Ansicht eines Mitarbeiters}
    \label{fig:impl:HomeMitarbeiter}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.5]{pics/kategorien_mitarbeiter.JPG}
    \caption{Kategorieanzeige eines Menüs}
    \label{fig:impl:CategoriesForMenue}
\end{figure}

\pagebreak

\subsubsection {Bestellansicht}

In der Bestellansicht werden die nötigen Daten für die Bestellung ausgefüllt. Die ersten drei Felder sind automatisch ausgefüllt, aufgrund der vorherigen Auswahl. \\*
Die Tabelle auf der rechten Seite enthält alle Bestellzeiträume, die es gibt. Man kann nur einen gleichzeitig auswählen. Außerdem stehen die freien Plätze dabei, die aus der Datenbank geladen werden.\\*
Die Anzahl der Menüs kann durchs Klicken des Plus- und Minusknopfs angepasst werden.  \\*
Darunter steht voreingestellt der Benutzer, doch dies kann verändert werden, um das Menü für einen anderen Mitarbeiter bestellen zu können. \\*
Abschließend kann man noch einen Kommentar an die Kantine mitgeben, falls es etwaige Extrawünsche geben sollte. \\*
Die Bestellung kann durch den Abschließen-Knopf durchgeführt werden und abbrechen kann man jederzeit mit dem Abbrechen-Knopf.
Die Bestellung ist erst ausführbar, sobald alle Felder außer des Kommentars ausgefüllt wurden.
\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.7]{pics/mitarbeiter-bestellen.JPG}
    \caption{Bestellansicht}
    \label{fig:impl:BestellenMitarbeiter}
\end{figure}
\pagebreak

\subsubsection {Bestellübersicht}

Die Bestellübersicht dient dem Benutzer dazu seine Bestellhistorie nachzuvollziehen. Zu jeder Bestellung ist der Name des bestellten Menüs, das Menüdatum, der Bestellzeitpunkt und die Essenszeit zugeordnet. \\*
Der Benutzer hat die Möglichkeit, oben in der Suchleiste, die Bestellungen nach Name oder Menüdatum zu filtern. Das Filtern erfolgt direkt nach der Eingabe. \\*
Man kann jede Bestellung anklicken und falls eine Bestellung die Stornierbedingungen erfüllt kann diese mit dem unten gelegen Storno-Button storniert werden.
Nach einer erfolgreichen Stornierung verschwindet die Bestellung aus dem Verlauf, doch in der Datenbank wird nur das Stornierdatum gesetzt und somit wird die Bestellung ungültig gemacht. 


\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.3]{pics/mitarbeiter-bestellen-übersicht.JPG}
    \caption{Bestellungsübersicht}
    \label{fig:impl:BestellenMitarbeiterUebersicht}
\end{figure}
\pagebreak

\subsubsection {Statistiken}

Der Benutzer kann in dieser Ansicht mehr Informationen über seine vergangenen Bestellungen bekommen.
Durch das Wechseln des Tabs oben links wird entweder eine Statistik über die Kategorien oder über die Wochentage angezeigt. \\*
Die Informationen der Statistiken beziehen sich auf alle Bestellungen, die der Nutzer bereits getätigt hat.

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.3]{pics/statistiken_kategorien.JPG}
    \caption{Kategorie Statistiken}
    \label{fig:impl:StatsCategories}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.3]{pics/statistiken_wochentage.JPG}
    \caption{Wochentage Statistiken}
    \label{fig:impl:WeekDaysCategories}
\end{figure}

\pagebreak

\subsection {Kantinen-Ansicht}
\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.125]{pics/activity-kantine.png}
    \caption{Die wichtigsten Aktivitäten der Kantine}
    \label{fig:impl:ActCanteen}
\end{figure}
\subsubsection {Home}

Die Startseite der Kantinenmitarbeiter ähnelt der Ansicht der Mitarbeiter. \hyperref[sec:MitHome]{Siehe hier}. \\*
Die Unterschiede sind, dass die Kantine Textfelder für jedes Menü und dessen Vor- und Nachspeise hat.
Ebenfalls erscheint beim Kategorien-Knopf eine Liste von Kategorien zum Anhaken, um dem Menü die entsprechenden Kategorien zuzuordnen. \\*
Die Textfelder und Kategorien können bearbeitet werden, um ein vorhandenes Menü zu aktualisieren oder um ein neues zu erstellen.
Die Erstellung bzw. die Änderung kann durch den Speichern-Knopf durchgeführt werden. Je nach Fall werden neue Menüs an das Backend geschickt oder ein
vorhandenes wird aktualisiert.

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.35]{pics/kantine_home.JPG}
    \caption{Kantine Homeansicht}
    \label{fig:impl:CantineHome}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.4]{pics/kategorien_kantine.JPG}
    \caption{Kategorieauswahl}
    \label{fig:impl:CategoryChooseCantine}
\end{figure}
\pagebreak

\subsubsection {Drucken}

Die Druckansicht dient den Kantinenmitarbeitern dazu, um die Bestellungen des jeweiligen Tages durchführen zu können.
Der Tag kann durch eine Datumsauswahl bestimmt werden.
Die Ansicht zeigt alle nötigen Informationen, damit die Kantine einen Überblick über die Bestellungen hat und dementsprechend das Essen vorbereiten kann.
Es sind die Essenszeiten sowie Anzahl der jeweiligen Menücodes summiert für einen schnellen Überblick. \\*
Durch das Drücken des Drucken-Knopfs hat die Kantine die Möglichkeit ein pdf-Dokument aus der kompletten Ansicht, die unter dem Knopf zu sehen ist, zu drucken.
Dies dient dazu, dass sie einen Ausdruck auf Papier haben, der für die Kantine praktischer ist.

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.45]{pics/kantine_drucken.JPG}
    \caption{Druckansicht der Kantine}
    \label{fig:impl:CantinePrint}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics[scale=0.45]{pics/pdf_ansicht.JPG}
    \caption{PDF der Ansicht}
    \label{fig:impl:CantinePrintPDF}
\end{figure}
\pagebreak

\section{Android-App}


Die Android App ist in verschiedene Packages unterteilt: 

\begin{itemize}
    \item api
    \item composable 
    \item dataClasses
\end{itemize}

Im api Package sind gibt es ein ApiObject, welcher alle URL's beinhaltet. Dies erleichtert die Konfiguration der Android Anwendung im Bezug auf das Kommunizieren mit dem Backend.
Noch dazu gibt es die ApiService Klasse, die alle Requests erledigt. 


ApiObject:
\begin{lstlisting}
    object ApiObject {
    @JvmField
    var initMenuesUrl = "http://10.0.2.2:8080/menue/menues/"

    @JvmField
    var bestellungUrl = "http://10.0.2.2:8080/menue/bestellung/"

    @JvmField
    var oeffnungszeiten = "http://10.0.2.2:8080/menue/oeffnungszeiten"

    @JvmField
    var keycloak = "http://10.0.2.2:8082/auth/realms/menuRealm/protocol/openid-connect/token"
}
\end{lstlisting}



Im composable Package sind jene Klassen mit einer View. Diese werden jeweils mit @Composable annotiert. Diese benutzen sich dann
entweder gegenseitig oder die Methoden der ApiService Klasse.
\\*
Im dataClasses Package sind die gebrauchten Entitäten und DTO's (Data Transfer Object).
Hier werden den Menüs, Bestellungen, Öffnungszeiten und dem Acces Token die einzelnen Felder zugewiesen.
\\*

Die MainActivity Klasse ist die Hauptklasse über die die ganze Oberfläche der Android Applikation aufgerufen wird. 
Sie zeigt auch noch die Bottom Navigation Bar, welche zur Navigierung zwischen Übersicht, Bestellansicht und Verlauf verwendet wird.







\pagebreak


\section{Login}
\begin{figure}[htp]
    \centering
    \author{Bozidar Spasenovic}
    \includegraphics[scale=0.1]{pics/LoginScreenAnndroid.png}
    \caption{Loginscreen Android}
    \label{fig:impl:LoginScreenAnndroid}
\end{figure}

\subsection{Authentification}
Die Authentifizierung erfolgt mit der Methode checkAccessToken, welche nichts anderes macht wie einen Request zum Keycloak-Server zu schicken.
Im Request wird nach einem Access-Token gefragton.
Ein User  ist vorhanden wenn ein Accestoken im Response vorhanden ist.

\begin{lstlisting}

    Button(onClick = {
        if (!name.isEmpty() && !password.isEmpty() && checkAccessToken()) {

            InitMenues()
            InitBestellungen(name)
            Toast.makeText(
                context,
                "Logged in successfully",
                Toast.LENGTH_SHORT
            ).show()
            isLoggedIn.value = true
            navController.navigate("uebersicht")

        }
    }) {
        Text(text = "Sign In")
    }

\end{lstlisting}




\subsubsection{checkAccessToken()}

Man schickt einen Request an http://10.0.2.2:8082/auth/realms/menuRealm/protocol/openid-connect/token mit einem passendem body.
Im body stehen die Felder die für den Request nötig sind wie zum Beispiel:
\begin{itemize}
    \item die Client ID
    \item der Grant Type 
    \item der Client Secret
    \item der Scope
    \item das Passwort
    \item der Username
\end{itemize}

Als Client wird ein OkHttpClient verwendet. Dieser erstellt einen neuen Aufruf mit dem erstelltem Request. 
Wird im Response ein Token zurückgegeben, so wird er gespeichert. In diesem Schritt werden gleichzeitig mehrere Threads verwendet und deswegen
einen countDownLatch eingebaut. Er ist eine Hilfe für das Warten zwischen einzelnen Threads.
Er wartet also vor der Rückgabe der Methode darauf, dass der Token gespeichert wird. 


\begin{lstlisting}
    client.newCall(request).enqueue(object : Callback {
        override fun onResponse(call: Call, response: Response) {
            response.use {
                if (response.isSuccessful) {
                    accessToken.value = response.body!!.string()
                }
                else{
                    throw IOException("Unexpected code $response")
                }
            }
            countDownLatch.countDown()
        }
        override fun onFailure(call: Call, e: IOException) {
            e.printStackTrace()
            countDownLatch.countDown()

        }
    })
    countDownLatch.await()
    return accessToken.value != ""
\end{lstlisting}


\pagebreak
\section{Übersicht}
\begin{figure}[htp]
    \centering
    \author{Bozidar Spasenovic}
    \includegraphics[scale=0.1]{pics/ÜbersichtViewAndroid.png}
    \caption{Übersicht Android}
    \label{fig:impl:ÜbersichtViewAndroid}
\end{figure}

In der Übersicht kann man mit einem Datepicker ein Datum auswählen, was dazu führt das die jeweiligen Menüs an dem Tag 
als Cards angezeigt werden. Noch dazu wird die jeweilige Vorspeise und Nachspeise angezeigt.

\subsection{Datepicker}
Der Datepicker in Kotlin wird als DatePickerDialog verwendet. Im Dialog wird das ausgewählte Datum in eine temporäre Variable gespeichert
und der Methode getMenuesForDate(date: String) übergeben. Anschließend wird der Wert in der Übersicht angezeigt und man wird wieder zurücknavigiert.

\begin{lstlisting}
    val datePickerDialog = DatePickerDialog(
        context,
        { _: DatePicker, year: Int, month: Int, dayOfMonth: Int ->
            var temp = month.inc()
            if (dayOfMonth >= 1 && dayOfMonth <= 9) {

                if (temp.toString().length == 1) {
                    date.value = "$year-0${temp}-0$dayOfMonth"
                } else {
                    date.value = "$year-${temp}-0$dayOfMonth"
                }
            } else {
                if (temp.toString().length == 1) {
                    date.value = "$year-0${temp}-$dayOfMonth"
                } else {
                    date.value = "$year-${temp}-$dayOfMonth"
                }
            }
            getMenuesForDate(date.value)
            uebersichtDate.value = date.value
            navController.navigate("uebersicht")
        }, year, month, day
    )
\end{lstlisting}


\subsubsection{getMenuesForDate}
Die Methode beinhaltet den Filteralgorhytmus von Menüs für einen Tag. Es wird erstmals überprüft ob das jetzige Datum voor dem Datum des Menüs ist
und ob die jetzige Zeit, falls man am selben Tag bestellt, vor neun Uhr ist. Sind die beiden Bedingungen erfüllt so wird es dem Mitarbeiter ermöglicht ein Menü auszuwählen.

\begin{lstlisting}
    if (date <= LocalDateTime.now().toString().take(10) && LocalDateTime.now().hour >= 9) {
        menueIsInThePast.value = true
    } else {
        menueIsInThePast.value = false
    }
    menuesFilteredByDate = menuesFilteredByDate - menuesFilteredByDate
    menues.sortedBy { menue -> menue.date }.sortedBy { menue -> menue.code }.forEach { menu ->
        if (menu.date == date) {
            menuesFilteredByDate = menuesFilteredByDate.plusElement(menu)
        }
    }
\end{lstlisting}

Dazu wird die Methode getOeffnungszeiten() aufgerufen die die notwendigen Zeiten mit freien Sitzplätzen aus dem Backend holt und anzeigt.


\begin{lstlisting}
    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            e.printStackTrace()
        }

        override fun onResponse(call: Call, response: Response) {
            response.use {
                if (!response.isSuccessful) throw IOException("Unexpected code $response")

                val gson = GsonBuilder().create()

                val collectionType: Type =
                    object : TypeToken<Collection<Oeffnungszeiten?>?>() {}.type
                oeffnungszeiten = gson.fromJson(response.body!!.string(), collectionType)
            }
        }
    })
\end{lstlisting}

\subsection{Card}
\cite{Card}
\author{Bozidar Spasenovic}

Eine Card wird verwendet um mehrere Items schön beisammen zu halten. Man kann die Card konfigurieren indem man die Erhöhung und den Schatten erhöht.
Außerdem kann man Formen definieren wie zum Beispiel:

\begin{itemize}
    \item Rectangle Shape
    \item Circle Shape
    \item Rounded Corner Shape
    \item Cut Corner Shape
\end{itemize}

Wie bei fast allen anderen Items, ist es auch hier möglich die Darstellung zu ändern.

\begin{itemize}
   \item modifier
   \item shape
   \item backgroundColor
   \item contentColor
   \item border
   \item elevation
   \item content
\end{itemize}

Dargestellt wird es mit einer einfachen Funktion.


\begin{lstlisting}
    Card {
        Text(
            text = "Card"
        )
    }
\end{lstlisting}

Um die einzelnen Modifizierungen einzubauen, gibt man der Funktion die jeweiligen Parameter mit.

\begin{lstlisting}
    Card(
        modifier: Modifier = Modifier,
        shape: Shape = RectangleShape(5.dp),
        backgroundColor: Color = Color.Transparent,
        contentColor: Color = Color.Red,
        elevation: Dp = 10.dp
    ) {
        Text(
            text = "Card"
        )
    }
\end{lstlisting}





\subsection{Log out}
Der Mitarbeiter hat eine Möglichkeit sich auch aus der App auszuloggen. Das erfolgt durch den Sign out Button.
\begin{figure}[htp]
    \centering
    \author{Bozidar Spasenovic}
    \includegraphics[scale=0.09]{pics/SignOutScreenAnndroid.png}
    \caption{Signout Android}
    \label{fig:impl:SignOutScreenAndroid}
\end{figure}

Nach dem Einloggen wird die Methode InitBestellungen() aufgerufen. Ihre Aufgabe ist es den derzeitigen Bestellungsverlauf des Mitarbeiters zu initialisieren.
Den kann man dann auch in der Verlaufsansicht sehen. Noch dazu wird die Methode InitMenues() aufgerufen und somit alle erstellten Menüs geholt.


\begin{lstlisting}
    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            e.printStackTrace()
        }

        override fun onResponse(call: Call, response: Response) {
            response.use {
                if (!response.isSuccessful) throw IOException("Unexpected code $response")

                val gson = GsonBuilder().create()

                val collectionType: Type =
                    object : TypeToken<Collection<Menue?>?>() {}.type


                menues = gson.fromJson(response.body!!.string(), collectionType)
            }
        }
    })
\end{lstlisting}


Der Response wird so benutzt, dass man als erstes mit dem GsonBuilder ein Gson-Objekt erstellt
 was das Umwandeln von JSON-Objekten zu Kotlin Objekten ermöglicht. 
Dieses Objekt wird verwendet um ein JSON-Objekt in ein Kotlin-Objekt umzuwandeln. 
Damit man Gson verwendetn kann, benötigt man die Abhängigkeit com.google.code.gson:gson:2.8.9.
Mit dem collectionType wird definiert in was für ein Typ das JSON-Objekt umgewandelt werden soll.
Abschliesend wird vom Responsebody eine Collection von allen mitgegebenen Bestellungen erstellt und gespeichert.


\pagebreak

\section{Verlauf}

Der Verlauf ist eine einfache Liste (LazyColumn) von den ganzen Bestellungen des Users.
Es wird der Menüname, das Bestelldatum und das Datum des Menüs angezeigt.
Ist die Bestellung stornierbar, so wird eine Mülltonne als Icon angezeigt. 
Durch das Draufklicken auf die Mülltonne, wird die Bestellung storniert.

\begin{figure}[htp]
    \centering
    \author{Bozidar Spasenovic}
    \includegraphics[scale=0.09]{pics/VerlaufAndroid.png}
    \caption{VerlaufAndroid Android}
    \label{fig:impl:VerlaufAndroid}
\end{figure}


Es wird ein PUT auf die URL http://10.0.2.2:8080/menue/bestellung?id=\$menuId was im backend das Löschen zur jeweiligen Menü Id ausübt.
Falls ein erfolgreicher Response zurückkommt, so wird die InitBestellungen()-Methode zum neu Laden des Verlaufes aufgerufen.

\begin{lstlisting}
    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            e.printStackTrace()
        }

        override fun onResponse(call: Call, response: Response) {
            response.use {
                if (!response.isSuccessful){
                    throw IOException("Unexpected code $response")
                }

                InitBestellungen(currUser.value)
            }
        }
    })
\end{lstlisting}


\pagebreak


\section{Bestellansicht}

In der Bestellansicht werden die Felder Menü, Von und das Datum automatisch in ein Readonly Text Field gespeichert.
Man kann dann die Anzahl angeben, für wen man es bestellen möchte und auch zwischen vier Zeiten aussuchen. 

\begin{figure}[htp]
    \centering
    \author{Bozidar Spasenovic}
    \includegraphics[scale=0.09]{pics/BestellübersichtAndroid.png}
    \caption{Bestellansicht Android}
    \label{fig:impl:BestellübersichtAndroid}
\end{figure}

\subsection{postBestellung()}
Nach dem Abschließen wird die postBestellung()-Methode aufgerufen. Sie erstellt einen Requestbody mit den eingegebenen Werten
und schickt es mittels POST an die \textit{http://10.0.2.2:8080/menue/bestellung/} URL. Dieser Endpoint führt dann die Anfrage durch und schickt einen Response zurück.
Wichtig dabei ist es den richtigen Media-Type zu definieren. 

Die Anfrage und Antwort:
\begin{lstlisting}
    client.newCall(requestDto).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            e.printStackTrace()
        }

        override fun onResponse(call: Call, response: Response) {
            response.use {
                if (!response.isSuccessful) throw IOException("Unexpected code $response")

                response.headers.get("orderedBy")?.let { it1 -> InitBestellungen(it1) }
            }
        }
    })
\end{lstlisting}


\subsubsection{Interface Callback}
\cite{Callback}
Da Java keine \textit{Pointer} Konzepte verwendet, gibt es die Callbackfunktion nicht wie in C oder C++.
Da hingegen gibt es das sogenannte Callback Interface.
Jede Schnittstelle hat einen Speicherort. Diese wird dann, anstatt der Funktion selbst, übergeben und verwendet.
\\*

\subsubsection{onResponse()}
Die onResponse Methode ist eine abstrakte, vom Interface Callback vorgegebene Hilfsmethode. Diese wird aufgerufen 
wenn ein Response erfolgreich war. Solange der \textit{ResponseBody} noch besteht, so ist der Response noch vorhanden.
Um ihn zu löschen, hat man den Body vorerst zu schließen.

\subsubsection{onFailure()}
Die onResponse Methode ist ebenso eine abstrakte, vom Interface Callback vorgegebene Hilfsmethode. Diese wird bei einem
nicht erfolgreichem Response aufgerufen. Ursachen wären Internetprobleme von der Server als auch Client Seite. 




